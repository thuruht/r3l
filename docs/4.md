/**
 * Updated src/index.ts
 * Includes Password Recovery, Email Verification, and Security Fixes.
 */

import { Hono } from 'hono';
import { sign, verify } from 'hono/jwt';
import { setCookie, getCookie, deleteCookie } from 'hono/cookie';
import { Resend } from 'resend';

// ... (Environment and Helpers omitted for space, assuming existing hashPassword function)

const app = new Hono<{ Bindings: Env, Variables: Variables }>();

// --- Security Fix: No Hardcoded Fallback ---
const authMiddleware = async (c: any, next: any) => {
  const token = getCookie(c, 'auth_token');
  const secret = c.env.JWT_SECRET;
  
  if (!token || !secret) {
    return c.json({ error: 'Unauthorized: Missing session or secret' }, 401);
  }

  try {
    const payload = await verify(token, secret);
    c.set('user_id', payload.id as number);
    await next();
  } catch (e) {
    return c.json({ error: 'Unauthorized: Invalid session' }, 401);
  }
};

// --- Password Recovery ---

app.post('/api/forgot-password', async (c) => {
  const { email } = await c.req.json();
  const user = await c.env.DB.prepare('SELECT id FROM users WHERE email = ?').bind(email).first();
  
  if (!user) return c.json({ message: 'If account exists, recovery link sent.' });

  const token = crypto.randomUUID();
  const expiry = new Date(Date.now() + 3600000).toISOString(); // 1 hour

  await c.env.DB.prepare('UPDATE users SET reset_token = ?, reset_expires = ? WHERE id = ?')
    .bind(token, expiry, user.id).run();

  if (c.env.RESEND_API_KEY) {
    const resend = new Resend(c.env.RESEND_API_KEY);
    await resend.emails.send({
      from: 'Rel F Support <recovery@r3l.distorted.work>',
      to: email,
      subject: 'Reset your Rel F Frequency',
      html: `<p>A reset was requested. <a href="https://r3l.distorted.work/reset-password?token=${token}">Reset Password</a></p>`
    });
  }

  return c.json({ message: 'Recovery link sent.' });
});

app.post('/api/reset-password', async (c) => {
  const { token, newPassword } = await c.req.json();
  const user = await c.env.DB.prepare('SELECT id FROM users WHERE reset_token = ? AND reset_expires > ?')
    .bind(token, new Date().toISOString()).first();

  if (!user) return c.json({ error: 'Invalid or expired token' }, 400);

  const { hash, salt } = await hashPassword(newPassword);
  await c.env.DB.prepare('UPDATE users SET password = ?, salt = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?')
    .bind(hash, salt, user.id).run();

  return c.json({ message: 'Password reset successful.' });
});

// --- Verification Enforcement ---

app.post('/api/login', async (c) => {
  const { username, password } = await c.req.json();
  const user = await c.env.DB.prepare('SELECT * FROM users WHERE username = ?').bind(username).first();

  if (!user) return c.json({ error: 'Invalid credentials' }, 401);

  const { hash: inputHash } = await hashPassword(password, user.salt as string);
  if (inputHash !== user.password) return c.json({ error: 'Invalid credentials' }, 401);

  if (!user.is_verified) {
    return c.json({ error: 'Identity not verified. Check your inbox.', needs_verification: true }, 403);
  }

  // Generate and Set JWT (omitted for space)
  return c.json({ success: true });
});

app.put('/api/users/me/public-key', authMiddleware, async (c) => {
  const user_id = c.get('user_id');
  const { public_key } = await c.req.json();
  await c.env.DB.prepare('UPDATE users SET public_key = ? WHERE id = ?').bind(public_key, user_id).run();
  return c.json({ success: true });
});

export default { fetch: app.fetch };
